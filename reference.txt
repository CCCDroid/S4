************************************
*     S4 Reference                 *
************************************

*** ARITHMETIC ***
+  (a b--a+b)     addition
-  (a b--a-b)     subtraction
*  (a b--a*b)     multiplication
/  (a b--a/b)     division

*** BIT MANIPULATION ***
&  (a b--n)       and
|  (a b--n)       or
^  (a b--n)       xor
~  (n1--n2)       ones complement (10110010 => 01001101)

*** STACK ***
#  (a--a a)       Duplicate TOS                          (Forth DUP)
\  (a b--a)       Drop TOS                               (Forth DROP)
$  (a b--b a)     Swap top 2 stack items                 (Forth SWAP)
%  (a b--a b a)   Push 2nd                               (Forth OVER)
r< (n--)          Move TOS to return stack               (Forth >R)
r@ (--n)          Fetch top of return stack              (Forth R@)
r> (--n)          Move top of return stack to data stack (Forth R>)

*** MEMORY ***
  NOTEs: There are 3 address spaces, CODE, MEMORY, and ABSOLUTE
         CODE and MEMORY addresses are indexes into that specific area of memory
         ABSOLUTE addresses are the addresses of the entire machine

        ** 8-bit operations: **
         these use 8-bit indexing and values
         E.G. - 28 c@ returns the lowest byte of HERE
c@    (a--n)      Fetch from MEMORY address a
c!    (n a--)     Store n to MEMORY address a
d@    (a--n)      Fetch from CODE address a
d!    (n a--)     Store n to CODE address a
m@    (a--n)      Fetch from ABSOLUTE address a
m!    (n a--)     Store n to ABSOLUTE address a

        ** 32-bit operations: **
         these use 32-bit indexing and values
         E.G. - 7 @ returns the 32-value of HERE
@     (a--n)      Fetch from MEMORY address a
!     (n a--)     Store n to MEMORY address a

*** REGISTERS ***
  NOTES: The registers are stored in MEMORY addresses [0..25]
         Register H is special: it is the HERE address
         Register initial values:
         - C: Size of CODE area
         - N: Size of FUNCTIONS array
         - Z: Size of MEMORY area
         - D: Start of CODE area
         - F: Start of FUNCTIONS array
         - M: Start of MEMORY area
         - R: Start of return stack
         - S: Start of data stack
         - Y: Start of system structure
         - All other registers set to 0
X   (--n)         Push value of register X (X:[A..Z])
X+  (--n)         Push value of register X, then increment the register by 1
X-  (--n)         Push value of register X, then decrement the register by 1
X;  (n--)         Set register X value to n

*** FUNCTIONS ***
  NOTES: 1) Function names are exactly 2 characters, case-sensitive
         2) The first character is ALPHA only
         3) The second character ALPHANUMERIC
         4) A function cannot have '}' embedded in it (eg - {bd "TE}ST"} will not compile correctly)
            Use {ok "TE"125,"ST"} instead
{XX  (--)         Define function XX (XX:[AA..z9])
}    (--)         End of function definition
:XX  (--)         Call function XX
;    (--)         Return from function immediately (i.e. - before reaching '}')
                    NOTE: returning while inside of a loop is not supported; behavior will be undefined.

*** INPUT/OUTPUT ***
.     (N--)       Output N as decimal number
,     (N--)       Output N as character (Forth EMIT)
b     (--)        Output a BLANK (32,)
n     (--)        Output a NEWLINE (13,10,)
?     ( --key)    Read one key, don't wait for ENTER.
"     (--)        Output characters until next '"'
_     (a1--a2)    String: copy string to address (a1) (eg - 1000_hello_)
                    Pushes address (a2) after terminating NULL
hX    (--n)       Scan HEX number X until non hex-digit (not case-sensitive, h3Da0 == h3dA0 )
0..9  (--n)       Scan DECIMAL number until non digit
                     to specify multiple values, separate them by space (4711 3333)
                     to enter a negative number, use '~1+' (eg - '32~1+') (make it a function!)
'x   (--n)        Push the ascii value of x (x: [any char possible])

*** CONDITIONS/FLOW CONTROL ***
<   (a b--f)      if (a < b), f=true, else f=false
>   (a b--f)      if (a > b), f=true, else f=false
=   (a b--f)      if (a = b), f=true, else f=false
(   (f--)         if (f != 0), execute code in '()', else skip until ')'
          NOTES: 1. You can NOT nest IFs
                 2. '()' cannot have ')' embedded in in (EG - a@("TE)ST"1-) fails when a=0)
                    USE a@("TE"41,"ST") instead
[   (f--f)        Begin while loop. If (f==0), skip code until ']'
]   (f--)         if (f != 0), repeat the loop, else drop f and continue.
          NOTES: 1. You can NOT nest LOOPs
                 2. '[]' cannot have ']' embedded in it (EG - a@["TE]ST"1-] fails when a=0)
                    USE a@("TE"93,"ST") instead
e   (A--)        Execute (call) address A
j   (A--)        Jump to address A
[[  (F T --)     For: start a For/Next loop. Swap F&T if (T < F)
]]  ( -- )       Next: increment index xI and loop if xI < T
xI  ( -- n)      Index: push the index of the current FOR loop
xJ  ( -- n)      Index: push the index of the 1st inner FOR loop
xK  ( -- n)      Index: push the index of the 2nd inner FOR loop

*** OTHER ***
iA    (--)         Info: All (CFMRS)
iC    (--)         Info: Code
iF    (--)         Info: Functions
iM    (--)         Info: Memory
iR    (--)         Info: Registers
iS    (--)         Info: Stack
l     (n--)        Load code from block (block.nnn)
t     (--n)        Time (Arduino: millis(), Windows: GetTickCount())
w     (n--)        Wait (Arduino: delay(),  Windows: Sleep())
xFO   (fn md--fh)  PC-File: open (fn/md: addr of name/mode, use `S"")
xFR   (fh--c n)    PC-File: read 1 char (n=0 means EOF)
xFW   (c fh--)     PC-File: write 1 char
xFC   (fh--)       PC-File: close
xFNxx (--A)        Function: resolve function address (xx: function name)
xPI   (p--)        Arduino: pin input  (pinMode(p, INPUT))
xPU   (p--)        Arduino: pin pullup (pinMode(p, INPUT_PULLUP))
xPO   (p--)        Arduino: pin output (pinMode(p, OUTPUT)
xPRA  (p--n)       Arduino: pin read analog  (n = analogRead(p))
xPRD  (p--n)       Arduino: pin read digital (n = digitalRead(p))
xPWA  (n p--)      Arduino: pin write analog  (analogWrite(p, n))
xPWD  (n p--)      Arduino: pin write digital (digitalWrite(p, n))
xT    (--)         Exit S4
xX    (--)         Reset S4 to initial state
